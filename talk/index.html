<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Talk · Hanung Gerry Purwaka</title>
    <meta name="description" content="Talk details" />
    <link rel="icon" href="/assets/logo.webp" type="image/webp" />
    <link rel="stylesheet" href="/styles.css" />
  </head>
  <body class="talk-page">
    <header class="site-header">
      <div class="container nav-bar">
        <a class="brand" href="/">
          <img class="brand-logo" src="/assets/logo.webp" alt="Hello, I'm Gerry" />
          <span class="brand-name">Hanung Gerry Purwaka</span>
        </a>
        <button class="menu-toggle" type="button" aria-expanded="false" aria-controls="site-nav">
          <img src="/assets/hamburger-icon.svg" alt="Open menu" />
        </button>
        <nav id="site-nav" class="site-nav">
          <a href="/">Home</a>
          <a href="/all-works/">All Works</a>
          <a href="/talks/">Talks</a>
          <a href="/about/">About Me</a>
          <a href="/contact/">Contact</a>
        </nav>
      </div>
    </header>

    <main>
      <section class="page-intro">
        <div class="container">
          <h1 id="talk-title">Talk</h1>
        </div>
      </section>

      <section class="page-content">
        <div class="container talk-detail">
          <div class="talk-figure">
            <img id="talk-image" src="" alt="" />
          </div>
          <div class="talk-body">
            <p id="talk-description" class="muted">Loading...</p>
          </div>
        </div>
      </section>
    </main>

    <footer class="site-footer">
      <div class="container footer-bar">
        <nav class="footer-nav" aria-label="Footer">
          <a href="/">Home</a>
          <a href="/all-works/">All Works</a>
          <a href="/talks/">Talks</a>
          <a href="/about/">About Me</a>
          <a href="/contact/">Contact</a>
        </nav>
      </div>
    </footer>

    <script>
      const toggle = document.querySelector(".menu-toggle");
      const nav = document.getElementById("site-nav");
      if (toggle && nav) {
        toggle.addEventListener("click", () => {
          const isOpen = document.body.classList.toggle("nav-open");
          toggle.setAttribute("aria-expanded", isOpen ? "true" : "false");
        });
      }

      const SHEET_PUBLISHED_ID =
        "2PACX-1vQxj47Ft36-DJffBs6j9p-g7DmJSEFnhHq2I91zytwv1QXb4s1kCnhfq63VRx1TyL999_WLp51NitM-";
      const SHEET_RICH_TEXT_URL =
        "https://script.google.com/macros/s/AKfycbxZs_7AcWL55LbUqurkiwQdn0nSix1odLxgRheuvoQo9Sdk6Ju-OTfNx1flHa7HpTmY/exec";
      const SHEET_GID = "196434583";
      const SHEET_URL = `https://docs.google.com/spreadsheets/d/e/${SHEET_PUBLISHED_ID}/pub?output=csv&gid=${SHEET_GID}`;
      const SHEET_GVIZ_URL = `https://docs.google.com/spreadsheets/d/e/${SHEET_PUBLISHED_ID}/gviz/tq?tqx=out:json&gid=${SHEET_GID}`;

      function parseCsv(text) {
        const rows = [];
        let row = [];
        let field = "";
        let inQuotes = false;
        for (let i = 0; i < text.length; i++) {
          const char = text[i];
          const next = text[i + 1];
          if (char === '"') {
            if (inQuotes && next === '"') {
              field += '"';
              i++;
            } else {
              inQuotes = !inQuotes;
            }
          } else if (char === "," && !inQuotes) {
            row.push(field);
            field = "";
          } else if ((char === "\n" || char === "\r") && !inQuotes) {
            if (char === "\r" && next === "\n") {
              i++;
            }
            row.push(field);
            if (row.length > 1 || row[0] !== "") {
              rows.push(row);
            }
            row = [];
            field = "";
          } else {
            field += char;
          }
        }
        if (field.length || row.length) {
          row.push(field);
          rows.push(row);
        }
        return rows;
      }

      function normalizeKey(value) {
        return String(value || "")
          .trim()
          .toLowerCase()
          .replace(/\s+/g, "_");
      }

      function makeFreshUrl(url) {
        const separator = url.includes("?") ? "&" : "?";
        return `${url}${separator}t=${Date.now()}`;
      }

      function parseGvizResponse(text) {
        const start = text.indexOf("{");
        const end = text.lastIndexOf("}");
        if (start === -1 || end === -1 || end <= start) {
          throw new Error("Invalid gviz response");
        }
        return JSON.parse(text.slice(start, end + 1));
      }

      function extractCellValue(cell) {
        if (!cell) return "";
        if (cell.v === null || cell.v === undefined) return "";
        return String(cell.v).trim();
      }

      function extractCellFormatted(cell) {
        if (!cell) return "";
        if (cell.f === null || cell.f === undefined) return "";
        return String(cell.f).trim();
      }

      function normalizeRichTextHtml(html) {
        const template = document.createElement("template");
        template.innerHTML = html;

        function sanitizeNode(node) {
          if (node.nodeType === Node.TEXT_NODE) return;
          if (node.nodeType !== Node.ELEMENT_NODE) {
            node.remove();
            return;
          }

          const element = node;
          const tagName = element.tagName.toUpperCase();

          if (tagName === "SPAN") {
            const style = (element.getAttribute("style") || "").toLowerCase();
            const hasBold =
              style.includes("font-weight:bold") ||
              style.includes("font-weight: bold") ||
              /font-weight\s*:\s*(?:[6-9]00|bold)/.test(style);
            if (hasBold) {
              const strong = document.createElement("strong");
              while (element.firstChild) {
                strong.appendChild(element.firstChild);
              }
              element.replaceWith(strong);
              sanitizeNode(strong);
              return;
            }
          }

          Array.from(element.childNodes).forEach(sanitizeNode);

          const allowed = new Set(["STRONG", "B", "BR", "A"]);
          if (!allowed.has(tagName)) {
            while (element.firstChild) {
              element.parentNode.insertBefore(element.firstChild, element);
            }
            element.remove();
            return;
          }

          if (tagName === "A") {
            const href = element.getAttribute("href") || "";
            if (!isSafeHref(href)) {
              while (element.firstChild) {
                element.parentNode.insertBefore(element.firstChild, element);
              }
              element.remove();
              return;
            }
            element.setAttribute("href", href);
            element.setAttribute("target", "_blank");
            element.setAttribute("rel", "noopener noreferrer");
            Array.from(element.attributes).forEach((attr) => {
              const key = attr.name.toLowerCase();
              if (key !== "href" && key !== "target" && key !== "rel") {
                element.removeAttribute(attr.name);
              }
            });
          } else {
            Array.from(element.attributes).forEach((attr) => {
              element.removeAttribute(attr.name);
            });
          }
        }

        Array.from(template.content.childNodes).forEach(sanitizeNode);
        return template.innerHTML.trim();
      }

      function isSafeHref(url) {
        const value = String(url || "").trim();
        if (!value) return false;
        if (value.startsWith("/")) return true;
        return /^(https?:|mailto:|tel:)/i.test(value);
      }

      function appendInlineContent(target, text, isBold) {
        const value = String(text || "");
        const linkPattern = /\[([^\]]+)\]\(([^)]+)\)/g;
        let lastIndex = 0;
        let match;

        function appendTextNode(content) {
          if (!content) return;
          const textNode = document.createTextNode(content);
          if (isBold) {
            const strong = document.createElement("strong");
            strong.appendChild(textNode);
            target.appendChild(strong);
          } else {
            target.appendChild(textNode);
          }
        }

        while ((match = linkPattern.exec(value)) !== null) {
          appendTextNode(value.slice(lastIndex, match.index));

          const label = match[1];
          const href = match[2].trim();
          if (!isSafeHref(href)) {
            appendTextNode(match[0]);
          } else {
            const link = document.createElement("a");
            link.href = href;
            link.target = "_blank";
            link.rel = "noopener noreferrer";
            link.textContent = label;
            if (isBold) {
              const strong = document.createElement("strong");
              strong.appendChild(link);
              target.appendChild(strong);
            } else {
              target.appendChild(link);
            }
          }
          lastIndex = linkPattern.lastIndex;
        }

        appendTextNode(value.slice(lastIndex));
      }

      function renderPlainTextWithLinks(element, text) {
        element.innerHTML = "";
        const lines = String(text || "").split("\n");
        lines.forEach((line, index) => {
          appendInlineContent(element, line, false);
          if (index < lines.length - 1) {
            element.appendChild(document.createElement("br"));
          }
        });
      }

      function replaceMarkdownLinksInTextNodes(root) {
        const walker = document.createTreeWalker(root, NodeFilter.SHOW_TEXT);
        const targets = [];
        let node;
        while ((node = walker.nextNode())) {
          const text = node.nodeValue || "";
          if (!/\[[^\]]+\]\([^)]+\)/.test(text)) continue;
          const parent = node.parentElement;
          if (parent && parent.tagName.toUpperCase() === "A") continue;
          targets.push(node);
        }

        targets.forEach((textNode) => {
          const fragment = document.createDocumentFragment();
          appendInlineContent(fragment, textNode.nodeValue || "", false);
          if (textNode.parentNode) {
            textNode.parentNode.replaceChild(fragment, textNode);
          }
        });
      }

      function renderRunsToFragment(runs) {
        const fragment = document.createDocumentFragment();

        runs.forEach((run) => {
          const text = String((run && run.text) || "");
          const parts = text.split("\n");
          parts.forEach((part, index) => {
            const isBold = !!(run && (run.bold || run.isBold));
            appendInlineContent(fragment, part, isBold);
            if (index < parts.length - 1) {
              fragment.appendChild(document.createElement("br"));
            }
          });
        });

        return fragment;
      }

      function getDescriptionRuns(item) {
        const candidates = [
          item && item.description__runs,
          item && item.description_runs,
          item && item.descriptionRuns
        ];
        for (const value of candidates) {
          if (Array.isArray(value)) return value;
          if (typeof value === "string") {
            try {
              const parsed = JSON.parse(value);
              if (Array.isArray(parsed)) return parsed;
            } catch (_) {}
          }
        }
        return [];
      }

      function getImageSource(item) {
        if (!item) return "";
        return String(
          item.image_url ||
            item.imageurl ||
            item.image ||
            item.data_url ||
            item.image_src ||
            ""
        ).trim();
      }

      function setDescriptionContent(element, formatted, plain, runs, fallbackText) {
        if (Array.isArray(runs) && runs.length) {
          element.innerHTML = "";
          element.appendChild(renderRunsToFragment(runs));
          return;
        }

        const fallback = plain || fallbackText;
        if (!formatted) {
          renderPlainTextWithLinks(element, fallback);
          return;
        }

        const safeHtml = normalizeRichTextHtml(formatted);
        if (!safeHtml) {
          renderPlainTextWithLinks(element, fallback);
          return;
        }
        element.innerHTML = safeHtml;
        replaceMarkdownLinksInTextNodes(element);
      }

      function fetchJsonp(url, timeoutMs = 10000) {
        return new Promise((resolve, reject) => {
          const callbackName = `__sheetJsonp_${Date.now()}_${Math.random()
            .toString(36)
            .slice(2)}`;
          const script = document.createElement("script");
          let settled = false;

          function cleanup() {
            if (script.parentNode) {
              script.parentNode.removeChild(script);
            }
            try {
              delete window[callbackName];
            } catch (_) {
              window[callbackName] = undefined;
            }
          }

          const timer = setTimeout(() => {
            if (settled) return;
            settled = true;
            cleanup();
            reject(new Error("JSONP timeout"));
          }, timeoutMs);

          window[callbackName] = (payload) => {
            if (settled) return;
            settled = true;
            clearTimeout(timer);
            cleanup();
            resolve(payload);
          };

          script.onerror = () => {
            if (settled) return;
            settled = true;
            clearTimeout(timer);
            cleanup();
            reject(new Error("JSONP script load failed"));
          };

          const sep = url.includes("?") ? "&" : "?";
          script.src = `${url}${sep}callback=${encodeURIComponent(callbackName)}`;
          document.head.appendChild(script);
        });
      }

      async function fetchSheetItems() {
        function normalizeRichItems(raw) {
          let rows = [];
          if (Array.isArray(raw)) {
            rows = raw;
          } else if (raw && Array.isArray(raw.rows)) {
            rows = raw.rows;
          } else if (raw && Array.isArray(raw.data)) {
            rows = raw.data;
          } else if (raw && typeof raw === "object") {
            const listCandidates = [
              raw.talks,
              raw.items,
              raw.values,
              raw.works,
              raw.all_works
            ].filter(Array.isArray);
            if (listCandidates.length) {
              rows = listCandidates[0];
            } else {
              rows = Object.values(raw).find(Array.isArray) || [];
            }
          }
          return rows.map((item) => {
            const normalized = {};
            Object.keys(item || {}).forEach((key) => {
              normalized[normalizeKey(key)] = item[key];
            });
            return normalized;
          });
        }

        try {
          const richPayload = await fetchJsonp(SHEET_RICH_TEXT_URL);
          const richItems = normalizeRichItems(richPayload);
          if (!richItems.length) throw new Error("Invalid rich text endpoint payload");
          return richItems;
        } catch (_) {
          // fallback to gviz/csv below
        }

        try {
          const response = await fetch(makeFreshUrl(SHEET_GVIZ_URL));
          if (!response.ok) throw new Error("gviz fetch failed");
          const text = await response.text();
          const payload = parseGvizResponse(text);
          const table = payload.table;
          if (!table || !Array.isArray(table.cols) || !Array.isArray(table.rows)) {
            throw new Error("Invalid gviz table");
          }

          const headers = table.cols.map((col) => normalizeKey(col.label || col.id));
          return table.rows.map((row) => {
            const item = {};
            headers.forEach((key, index) => {
              const cell = row.c && row.c[index] ? row.c[index] : null;
              item[key] = extractCellValue(cell);
              item[`${key}__formatted`] = extractCellFormatted(cell);
            });
            return item;
          });
        } catch (_) {
          const res = await fetch(makeFreshUrl(SHEET_URL));
          if (!res.ok) throw new Error("Sheet fetch failed");
          const text = await res.text();
          const rows = parseCsv(text);
          if (!rows.length) throw new Error("No data");
          const headers = rows[0].map(normalizeKey);
          return rows.slice(1).map((row) => {
            const item = {};
            headers.forEach((key, index) => {
              const value = row[index] ? row[index].trim() : "";
              item[key] = value;
              item[`${key}__formatted`] = value;
            });
            return item;
          });
        }
      }

      async function fetchTalkItemsFromCsvOnly() {
        const res = await fetch(makeFreshUrl(SHEET_URL));
        if (!res.ok) throw new Error("Sheet fetch failed");
        const text = await res.text();
        const rows = parseCsv(text);
        if (!rows.length) throw new Error("No data");
        const headers = rows[0].map(normalizeKey);
        return rows.slice(1).map((row) => {
          const item = {};
          headers.forEach((key, index) => {
            const value = row[index] ? row[index].trim() : "";
            item[key] = value;
            item[`${key}__formatted`] = value;
          });
          return item;
        });
      }

      function normalizeId(value) {
        return decodeURIComponent(String(value || ""))
          .trim()
          .replace(/\/+$/, "")
          .toLowerCase();
      }

      function findTalkBySlug(items, slug) {
        const normalizedSlug = normalizeId(slug);
        if (!normalizedSlug) return null;
        return items.find((item) => normalizeId(item.id) === normalizedSlug) || null;
      }

      function getSlug() {
        const params = new URLSearchParams(window.location.search);
        return normalizeId(params.get("id"));
      }

      async function loadTalk() {
        const slug = getSlug();
        const titleEl = document.getElementById("talk-title");
        const imageEl = document.getElementById("talk-image");
        const descEl = document.getElementById("talk-description");
        if (!slug) {
          descEl.textContent = "Talk not found.";
          return;
        }
        try {
          let items = await fetchSheetItems();
          let talk = findTalkBySlug(items, slug);
          if (!talk) {
            items = await fetchTalkItemsFromCsvOnly();
            talk = findTalkBySlug(items, slug);
          }
          if (!talk) {
            descEl.textContent = "Talk not found.";
            return;
          }
          titleEl.textContent = talk.title || "Talk";
          document.title = `${talk.title || "Talk"} · Hanung Gerry Purwaka`;
          imageEl.src = getImageSource(talk);
          imageEl.alt = talk.title || "Talk image";
          setDescriptionContent(
            descEl,
            talk.description__formatted,
            talk.description,
            getDescriptionRuns(talk),
            "Details coming soon."
          );
        } catch (err) {
          descEl.textContent = "Unable to load talk. Please refresh.";
        }
      }

      loadTalk();
    </script>
  </body>
</html>
